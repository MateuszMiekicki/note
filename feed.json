{
    "version": "https://jsonfeed.org/version/1",
    "title": "My note",
    "description": "",
    "home_page_url": "https://mateuszmiekicki.github.io/note",
    "feed_url": "https://mateuszmiekicki.github.io/note/feed.json",
    "user_comment": "",
    "author": {
        "name": "Mateusz Miękicki"
    },
    "items": [
        {
            "id": "https://mateuszmiekicki.github.io/note/jenkins-w-dokerze-i-dockerowy-pipeline/index.html",
            "url": "https://mateuszmiekicki.github.io/note/jenkins-w-dokerze-i-dockerowy-pipeline/index.html",
            "title": "Jenkins w dokerze i dockerowy pipeline",
            "content_html": "<h2>TL;DR</h2>\n<p>Zainstaluj dockera na w WSL i ustaw do niego ścieżkę w docker-compose. </p>\n<h2>Założenie</h2>\n<h3>Lead</h3>\n<p>Uruchomienie Jenkinsa w kontenerze opartym na Dockerze. Dodatkowo chcemy uruchomić nowy obraz Dockera w obecnym obrazie Jenkinsa. Reasumując, chcemy stworzyć kontener, który uruchomi nowy obraz przy każdorazowym uruchomieniu pipelinu. </p>\n<h3>Jednostka testowa:</h3>\n<ul>\n<li>Urządzenie\n<ul>\n<li>Processor i7-9750H CPU @ 2.60GHz</li>\n<li>RAM 16.0 GB </li>\n</ul>\n</li>\n<li>Software\n<ul>\n<li>Windows 11 Pro x64\n<ul>\n<li>Version 21H2</li>\n<li>OS build 22000.348</li>\n</ul>\n</li>\n<li>Docker version 20.10.10, build b485636</li>\n<li>Docker Compose version v2.1.1</li>\n<li>Ubuntu 20.04 LTS\n<ul>\n<li>5.10.60.1-microsoft-standard-WSL2</li>\n<li>focal</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Lista kroków od początku do końca</h2>\n<ol>\n<li>Włącz WSL 2<a href=\"#INTERNAL_LINK#/post/null\" title=\"https://docs.microsoft.com/en-us/windows/wsl/install\"> https://docs.microsoft.com/en-us/windows/wsl/install</a>\n<ol>\n<li>Zainstaluj Ubuntu oraz zaktualizuj repozytorium. <a href=\"#INTERNAL_LINK#/post/null\" title=\"https://ubuntu.com/wsl\">https://ubuntu.com/wsl</a></li>\n<li>Zainstaluj Dockera dla Ubuntu <a href=\"#INTERNAL_LINK#/post/null\" title=\"https://docs.docker.com/engine/install/ubuntu/\">https://docs.docker.com/engine/install/ubuntu/</a></li>\n</ol>\n</li>\n<li>Zainstaluj \"Docker Desktop on Windows\" <a href=\"#INTERNAL_LINK#/post/null\" title=\"https://docs.docker.com/desktop/windows/install/\">https://docs.docker.com/desktop/windows/install/</a></li>\n<li>Utwórz folder z plikiem docker-compose\n<pre>#docker-compose.yml<br>services:<br>  jenkins:<br>    container_name: jenkins<br>    build: .<br>    privileged: true<br>    user: root<br>    ports:<br>      - 8081:8080<br>      - 50000:50000<br>    volumes:<br>      - ~/jenkins:/var/jenkins_home<br>      - /var/run/docker.sock:/var/run/docker.sock<br>      - /usr/bin/docker:/usr/local/bin/docker<br><br>volumes:<br>  jenkins_home:</pre>\n<p>oraz z Dockerfilem(sam obraz Jenkinsa może być inny, jdk w tym przypadku nie będzie potrzebne)</p>\n<pre><code>#Dockerfile</code><br><code>FROM jenkins/jenkins:lts-jdk11</code><br><code>USER root</code><br><code>RUN apt-get -y update &amp;&amp; \\</code><br><code>    apt-get -y upgrade &amp;&amp; \\</code><br><code>    apt-get install -y wget &amp;&amp; \\</code><br><code>    apt-get install -y unzip &amp;&amp; \\</code><br><code>    apt-get install -y nano &amp;&amp; \\</code><br><code>    apt-get install -y cmake &amp;&amp; \\</code><br><code>    apt-get install -y gcc &amp;&amp; \\</code><br><code>    rm -rf /var/lib/apt/lists/*</code><br><code># COPY plugins.txt /usr/share/jenkins/plugins.txt</code><br><code># RUN jenkins-plugin-cli -f /usr/share/jenkins/plugins.txt</code></pre>\n<ol>\n<li>nasza_ścieżka:ścieżka_docker</li>\n<li><strong>~/jenkins:/var/jenkins_home - </strong>miejsce gdzie zapiszą się ustawienia Jenkinsa</li>\n<li><strong>/var/run/docker.sock:/var/run/docker.sock - </strong>miejsce gdzie docker będzie szukał domyślnych portów</li>\n<li><strong>/usr/bin/docker:/usr/local/bin/docker - </strong>miejsce gdzie zainstalowaliśmy dockera na/w Ubuntu(tym na WSL)</li>\n</ol>\n</li>\n<li>Wchodzimy w folder gdzie znajdują się wyżej wspomniane pliki, uruchamiamy konsole i wpisujemy \n<pre><code>docker-compose up -d</code></pre>\nW tym momencie kontener powinien się zbudować jednocześnie zaciągając obraz z dockerhuba. </li>\n<li>Odpalamy przeglądarkę i wpisujemy <a href=\"#INTERNAL_LINK#/post/null\" title=\"http://localhost:8081/\">http://localhost:8081/</a></li>\n<li>\n<p>Tworzymy nowy projekt. Z racji, że chce jak najszybciej zobaczyć efekt wpisuję pipeline z \"palca\" w sekcji konfiguracja </p>\n<pre><code>pipeline {</code><br><code>    agent {</code><br><code>        docker { image 'rikorose/gcc-cmake' }</code><br><code>    }</code><br><code>    stages {</code><br><code>        stage('gcc') {</code><br><code>            steps {</code><br><code>                sh 'gcc --version'</code><br><code>            }</code><br><code>        }</code><br><code>        stage('cmake') {</code><br><code>            steps {</code><br><code>                sh 'cmake --version'</code><br><code>            }</code><br><code>        }</code><br><code>    }</code><br><code>}</code></pre>\n</li>\n<li> Efektem powinno być wyświetlenie obecnych wersji g++ i CMake w wyjściu konsoli Jenkinsa</li>\n</ol>\n<h2>Uwagi</h2>\n<p>Czy warto uruchamiać każdorazowo obraz z czymś, co możemy zainstalować raz? Imo nie. W tym przypadku dużo lepszym wyborem jest zainstalowanie CMake i GCC osobno. Z racji, że nasze działania nie mają wpływu na te narzędzia. Oczywiście przy testach integracyjnych takie podejście będzie lepsze, to znaczy każdorazowe tworzenie nowego obrazu bazy, by zachować powtarzalność. </p>\n<h2>Wersja z \"statycznym\" CMakiem i GCC</h2>\n<p>Generalnie zostaje to co było, bo i tak Jenkins będzie nam potrzebny. Zmieni się jedynie źródło naszych narzędzi. Są one pobierane przy tworzeniu kontenera. </p>\n<h3>Nowy pipeline</h3>\n<pre><code>pipeline {</code><br><code>    agent any</code><br><code>    stages {</code><br><code>        stage('gcc') {</code><br><code>            steps {</code><br><code>                sh 'gcc --version'</code><br><code>            }</code><br><code>        }</code><br><code>        stage('cmake') {</code><br><code>            steps {</code><br><code>                sh 'cmake --version'</code><br><code>            }</code><br><code>        }</code><br><code>    }</code><br><code>}</code></pre>\n<p>Różnica jest w agencie, nie używamy żadnego. Poza tym zostaje to, co było. </p>",
            "author": {
                "name": "Mateusz Miękicki"
            },
            "tags": [
                   "jenkins",
                   "docker"
            ],
            "date_published": "2021-11-24T20:07:09+01:00",
            "date_modified": "2021-11-29T23:50:32+01:00"
        }
    ]
}
